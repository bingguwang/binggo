#### 缓存穿透
指的是要访问的数据既不在redis中，也不在mysql中。
请求redis发现数据不存在，继续访问mysql发现数据还是不存在，因为不存在所以没写回缓存，于是下次继续请求的时候还是会打到mysql。

解决方案：
- 缓存空值或者缺省值
    mysql里也没找到的时候，就写回缓存一个空值或缺省值，这样下次缓存就会命中避免访问mysql了
    在gozero的缓存的实现里，就有这个实现，当查询数据库未找到时，会在缓存里设一个key-缺省值
    if err = query(v); errors.Is(err, c.errNotFound) {
        if err = c.setCacheWithNotFound(ctx, key); err != nil {
        	logger.Error(err)
    }


- 使用布隆过滤器
    布隆过滤器由一个初值都为0的bit数组和N个哈希函数组成，
    用于快速判断某个数据是否不存在
    （如果布隆过滤器不存在数据库中一定不存在，如果布隆过滤器判断存在，数据库不一定存在，这是布隆过滤器的机制决定的）
    当我们想标记某个数据存在时（例如，数据已被写入数据库），布隆过滤器会通过三个操作完成标记：

    首先，使用N个哈希函数，分别计算这个数据的哈希值，得到N个哈希值。
    然后，我们把这N个哈希值对bit数组的长度取模，得到每个哈希值在数组中的对应位置。
    最后，我们把对应位置的bit位设置为1，这就完成了在布隆过滤器中标记数据的操作。
    如果数据不存在（例如，数据库里没有写入数据），我们也就没有用布隆过滤器标记过数据，那么，bit数组对应bit位的值仍然为0。

    所以当我们写入数据库时，使用布隆过滤器做个标记。当缓存缺失后，应用查询数据库时，可以通过查询布隆过滤器快速判断数据是否存在。
    如果不存在，就不用再去数据库中查询了。

    过滤器有个特点，即可以根据为0确定数据一定不存在，而为1不能确定数据一定存在，所以map里只支持数据改为1，但不支持改回0
    如果我们简单地将某个位置的位设回0，可能会误删其他元素的存在标记。因此布隆过滤器在设计上不支持删除操作

    实现方式有很多种，可以用redis的bitmap，可以用hashmap实现


#### 缓存击穿

一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，
当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就好像堤坝突然破了一个口，大量洪水汹涌而入。


解决方案：
既然是热点key，那么说明该key会一直被访问，既然如此，我们就不对这个key设置失效时间了
但是这个key需要更新了怎么办？
我们可以后台开启一个异步线程，发现过期的key直接重写缓存即可。
当然，这种解决方案只适用于不要求数据严格一致性的情况，因为当后台线程在构建缓存的时候，其他的线程很有可能也在读取数据，这样就会访问到旧数据了。
如果要严格保证数据一致的话，可以用分布式锁

除此外，还可以用singleFlight方案
也就是，多个请求同时请求同一个缓存键时，只允许一个请求去真正访问数据源（如数据库），其他请求等待该请求完成后，直接使用其结果
在gozero里，通过c.barrier.DoEx方法已经确保在高并发场景下，相同 key 的请求只会有一个真正去访问数据库，从而有效防止缓存击穿。
但注意，go-zero的singleFlight其实是参考的go的原语sync/singleFlight，也是通过 mutex + map 实现的，这不能保证分布式环境有效，
分布式要用分布式锁等其他的方式


#### 缓存雪崩

大量的请求无法在redis中处理（redis没拦住），直接打到了mysql，导致数据库压力激增，甚至服务崩溃。

redis无法处理的原因有两种：

- 缓存中大量数据同时过期

解决方案：
给过期时间增加一个较小的随机数，过期的数据通过时间去分摊
服务降级，直接返回错误信息


- 另外如果Redis缓存实例发生故障宕机了，无法处理请求，这就会导致大量请求一下子积压到数据库层，也导致雪崩

解决方案：
服务熔断或者请求限流，redis客户端直接返回，不会请求到redis服务，但是影响范围比较大
构建redis集群，提高可用性













