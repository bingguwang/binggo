

试想一下，很多时候我们只是希望知道一个数据存不存在
比如，秒杀时判断某个用户是否已参与活动，再比如缓存穿透的情况
而这个时候我们可能会直接去访问缓存或数据库
在并发量小的时候还可接受，办法量大的时候就会造成数据库或缓存压力过大

    布隆过滤器由一个初值都为0的bit数组和N个哈希函数组成，
    用于快速判断某个数据是否不存在
    （如果布隆过滤器不存在数据库中一定不存在，如果布隆过滤器判断存在，数据库不一定存在，这是布隆过滤器的机制决定的）
    当我们想标记某个数据存在时（例如，数据已被写入数据库），布隆过滤器会通过三个操作完成标记：

    首先，使用N个哈希函数，分别计算这个数据的哈希值，得到N个哈希值。
    然后，我们把这N个哈希值对bit数组的长度取模，得到每个哈希值在数组中的对应位置。
    最后，我们把对应位置的bit位设置为1，这就完成了在布隆过滤器中标记数据的操作。
    如果数据不存在（例如，数据库里没有写入数据），我们也就没有用布隆过滤器标记过数据，那么，bit数组对应bit位的值仍然为0。

    所以当我们写入数据库时，使用布隆过滤器做个标记。当缓存缺失后，应用查询数据库时，可以通过查询布隆过滤器快速判断数据是否存在。
    如果不存在，就不用再去数据库中查询了。

    https://juejin.cn/post/7026541493833695239#heading-0

    过滤器有个特点，即可以根据为0确定数据一定不存在，而为1不能确定数据一定存在（因为当元素非常多时散列函数产生的k位点可能会重复），所以map里只支持数据改为1，但不支持改回0
    如果我们简单地将某个位置的位设回0，可能会误删其他元素的存在标记(位数组中的某些k点是多个元素重复使用的，假如我们将其中一个元素的k点全部置为0则直接就会影响其他元素)。
    因此布隆过滤器在设计上不支持删除操作
    那脏数据怎么办，可以通过重建的方式来实现，但不要直接删除【详细操作见下面】

    实现方式有很多种，可以用redis的bitmap，可以用hashmap实现


## 如何处理掉脏数据
生成新的布隆过滤器：
    定期生成一个新的布隆过滤器，并将当前数据库中的所有有效数据重新插入到这个新的布隆过滤器中。
保持原有数据的可用性：
    在生成新的布隆过滤器的过程中，不删除原有的布隆过滤器，以保证系统在这个过程中依然可以正常工作。
原子操作替换旧布隆过滤器：
    当新的布隆过滤器构建完成后，通过Redis的rename命令将新的布隆过滤器替换旧的布隆过滤器。
    rename是一个原子操作，这意味着在替换的瞬间，系统将开始使用新的布隆过滤器而不会出现任何中断。
删除旧布隆过滤器：替换完成后，删除旧的布隆过滤器，以释放资源。

举例说明:
假设现有的布隆过滤器的键为bloom_filter，我们要定期重建这个过滤器：
- 生成新的布隆过滤器：
    生成一个新的布隆过滤器，并命名为bloom_filter_new。
- 将数据库中的所有有效数据插入到bloom_filter_new中。
- 替换旧布隆过滤器
    使用rename命令将bloom_filter_new重命名为bloom_filter。在这个过程中，Redis会保证重命名操作是原子的。
- 删除旧布隆过滤器

详细操作代码见 bloom_rebuild_test.go

