package main

import (
	"fmt"
)

// 商品的体积 2、3、4、5
var w = []int{0, 2, 3, 4, 5}

// 商品的价值 3、4、5、6
var v = []int{0, 3, 4, 5, 6}

// 背包大小
var bagV = 8

// 动态规划表
var dp [5][9]int

// 最优解情况
var item [5]int

// 动态规划函数
func findMax() {
	//dp[i][j] = max(第i个物品不选时的最大价值， 第i个物品选时的最大价值) ,i 从1开始
	//dp[i][j] = max(dp[i-1][j]， dp[i-1][j-wi]+ vi) j>=wi
	for i := 1; i <= 4; i++ {
		for j := 1; j <= bagV; j++ {
			if j < w[i] { // 第i个物品只能不选
				dp[i][j] = dp[i-1][j]
			} else { //  第i个物品可以选或不选
				dp[i][j] = max(dp[i-1][j], dp[i-1][j-w[i]]+v[i])
			}
		}
	}
}

/**
背包问题最优解回溯
通过上面的方法可以求出背包问题的最优解，但还不知道这个最优解由哪些商品组成，故要根据最优解回溯找出解的组成，根据填表的原理可以有如下的寻解方式：

V(i,j)=V(i-1,j)时，说明没有选择第i 个商品，则回到V(i-1,j)；
V(i,j)=V(i-1,j-w(i))+v(i)时，说明装了第i个商品，该商品是最优解组成的一部分，随后我们得回到装该商品之前，即回到V(i-1,j-w(i))；
一直遍历到i＝0结束为止，所有解的组成都会找到。
就拿上面的例子来说吧：

最优解为V(4,8)=10，而V(4,8)!=V(3,8)却有V(4,8)=V(3,8-w(4))+v(4)=V(3,3)+6=4+6=10，所以第4件商品被选中，并且回到V(3,8-w(4))=V(3,3)；
有V(3,3)=V(2,3)=4，所以第3件商品没被选择，回到V(2,3)；
而V(2,3)!=V(1,3)却有V(2,3)=V(1,3-w(2))+v(2)=V(1,0)+4=0+4=4，所以第2件商品被选中，并且回到V(1,3-w(2))=V(1,0)；
有V(1,0)=V(0,0)=0，所以第1件商品没被选择。

*/
// 回溯找到最优解
func findWhat(i, j int) {
	if i > 0 {
		if dp[i][j] == dp[i-1][j] {
			item[i] = 0
			findWhat(i-1, j)
		} else if j-w[i] >= 0 && dp[i][j] == dp[i-1][j-w[i]]+v[i] { // 第i个物品是最优解里的一个
			item[i] = 1
			findWhat(i-1, j-w[i])
		}
	}
}

// 输出动态规划表和最优解
func printResults() {
	// 动态规划表输出
	for i := 0; i < 5; i++ {
		for j := 0; j < 9; j++ {
			fmt.Printf("%d ", dp[i][j])
		}
		fmt.Println()
	}
	fmt.Println()

	// 最优解输出
	for i := 0; i < 5; i++ {
		fmt.Printf("%d ", item[i])
	}
	fmt.Println()
}

func main() {
	// 动态规划三部曲

	// 初始化动态规划表的第一行和第一列为0
	for j := 0; j < 9; j++ {
		dp[0][j] = 0
	}
	for i := 0; i < 5; i++ {
		dp[i][0] = 0
	}
	// 执行动态规划
	findMax()
	// 由于dp[i][j]表示 前i个物品里选择，且体积为j时，背包里的最大价值，并不知道选了哪些物品，所以需要回溯去找出选了哪些物品
	// 回溯找到最优解
	findWhat(4, 8)

	// 输出结果
	printResults()
}
